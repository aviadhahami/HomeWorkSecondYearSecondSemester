import java.util.Arrays;

/*
 * Generated by Aviad Hahami
 * 302188347
 */
public class MergeSort implements Sort {
	/*
	 * Normal merge sort implementation
	 */

	private int[] m_NumbersArray;
	private int[] m_HelperArray;

	private int m_ArraySize;

	public int[] sort(int[] input) {
		this.m_NumbersArray = input;
		this.m_ArraySize = input.length;
		this.m_HelperArray = new int[m_ArraySize];
		mergeSort(0, m_ArraySize - 1);

		return this.m_NumbersArray;
	}

	private void mergeSort(int i_Low, int i_High) {

		// check if low is smaller then high, if not then the array is sorted
		if (i_Low < i_High) {

			// Get the index of the element which is in the middle
			int i_ArrayMiddle = i_Low + (i_High - i_Low) / 2;

			// Sort the left side of the array
			mergeSort(i_Low, i_ArrayMiddle);

			// Sort the right side of the array
			mergeSort(i_ArrayMiddle + 1, i_High);

			// Combine them both
			merge(i_Low, i_ArrayMiddle, i_High);
		}
	}

	private void merge(int i_Low, int i_Middle, int i_High) {

		// Copy both parts into the helper array
		for (int i = i_Low; i <= i_High; i++) {
			m_HelperArray[i] = m_NumbersArray[i];
		}

		int i = i_Low;
		int j = i_Middle + 1;
		int k = i_Low;
		// Copy the smallest values from either the left or the right side back
		// to the original array
		while (i <= i_Middle && j <= i_High) {
			if (m_HelperArray[i] <= m_HelperArray[j]) {
				m_NumbersArray[k] = m_HelperArray[i];
				i++;
			} else {
				m_NumbersArray[k] = m_HelperArray[j];
				j++;
			}
			k++;
		}
		// Copy the rest of the left side of the array into the target array
		while (i <= i_Middle) {
			m_NumbersArray[k] = m_HelperArray[i];
			k++;
			i++;
		}

	}
}
